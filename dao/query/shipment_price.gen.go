// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"shaanmei_backend/dao/model"
)

func newShipmentPrice(db *gorm.DB, opts ...gen.DOOption) shipmentPrice {
	_shipmentPrice := shipmentPrice{}

	_shipmentPrice.shipmentPriceDo.UseDB(db, opts...)
	_shipmentPrice.shipmentPriceDo.UseModel(&model.ShipmentPrice{})

	tableName := _shipmentPrice.shipmentPriceDo.TableName()
	_shipmentPrice.ALL = field.NewAsterisk(tableName)
	_shipmentPrice.ID = field.NewInt32(tableName, "id")
	_shipmentPrice.OriginLongitude = field.NewFloat32(tableName, "origin_longitude")
	_shipmentPrice.OriginLatitude = field.NewFloat32(tableName, "origin_latitude")
	_shipmentPrice.OriginName = field.NewString(tableName, "origin_name")
	_shipmentPrice.OriginProvince = field.NewString(tableName, "origin_province")
	_shipmentPrice.OriginCity = field.NewString(tableName, "origin_city")
	_shipmentPrice.OriginCounty = field.NewString(tableName, "origin_county")
	_shipmentPrice.DestinationLongitude = field.NewFloat32(tableName, "destination_longitude")
	_shipmentPrice.DestinationLatitude = field.NewFloat32(tableName, "destination_latitude")
	_shipmentPrice.DestinationProvince = field.NewString(tableName, "destination_province")
	_shipmentPrice.DestinationCity = field.NewString(tableName, "destination_city")
	_shipmentPrice.DestinationCounty = field.NewString(tableName, "destination_county")
	_shipmentPrice.ShipmentUnitPrice = field.NewFloat32(tableName, "shipment_unit_price")
	_shipmentPrice.ShipmentDistance = field.NewFloat32(tableName, "shipment_distance")
	_shipmentPrice.ArrivalTime = field.NewTime(tableName, "arrival_time")
	_shipmentPrice.ProductType = field.NewString(tableName, "product_type")
	_shipmentPrice.VehicleType = field.NewString(tableName, "vehicle_type")
	_shipmentPrice.UnloadWeight = field.NewFloat32(tableName, "unload_weight")
	_shipmentPrice.VehicleName = field.NewString(tableName, "vehicle_name")
	_shipmentPrice.DriverName = field.NewString(tableName, "driver_name")
	_shipmentPrice.OwnerName = field.NewString(tableName, "owner_name")
	_shipmentPrice.CarrierName = field.NewString(tableName, "carrier_name")

	_shipmentPrice.fillFieldMap()

	return _shipmentPrice
}

type shipmentPrice struct {
	shipmentPriceDo shipmentPriceDo

	ALL                  field.Asterisk
	ID                   field.Int32
	OriginLongitude      field.Float32
	OriginLatitude       field.Float32
	OriginName           field.String
	OriginProvince       field.String
	OriginCity           field.String
	OriginCounty         field.String
	DestinationLongitude field.Float32
	DestinationLatitude  field.Float32
	DestinationProvince  field.String
	DestinationCity      field.String
	DestinationCounty    field.String
	ShipmentUnitPrice    field.Float32
	ShipmentDistance     field.Float32
	ArrivalTime          field.Time
	ProductType          field.String
	VehicleType          field.String
	UnloadWeight         field.Float32
	VehicleName          field.String
	DriverName           field.String
	OwnerName            field.String
	CarrierName          field.String

	fieldMap map[string]field.Expr
}

func (s shipmentPrice) Table(newTableName string) *shipmentPrice {
	s.shipmentPriceDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s shipmentPrice) As(alias string) *shipmentPrice {
	s.shipmentPriceDo.DO = *(s.shipmentPriceDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *shipmentPrice) updateTableName(table string) *shipmentPrice {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt32(table, "id")
	s.OriginLongitude = field.NewFloat32(table, "origin_longitude")
	s.OriginLatitude = field.NewFloat32(table, "origin_latitude")
	s.OriginName = field.NewString(table, "origin_name")
	s.OriginProvince = field.NewString(table, "origin_province")
	s.OriginCity = field.NewString(table, "origin_city")
	s.OriginCounty = field.NewString(table, "origin_county")
	s.DestinationLongitude = field.NewFloat32(table, "destination_longitude")
	s.DestinationLatitude = field.NewFloat32(table, "destination_latitude")
	s.DestinationProvince = field.NewString(table, "destination_province")
	s.DestinationCity = field.NewString(table, "destination_city")
	s.DestinationCounty = field.NewString(table, "destination_county")
	s.ShipmentUnitPrice = field.NewFloat32(table, "shipment_unit_price")
	s.ShipmentDistance = field.NewFloat32(table, "shipment_distance")
	s.ArrivalTime = field.NewTime(table, "arrival_time")
	s.ProductType = field.NewString(table, "product_type")
	s.VehicleType = field.NewString(table, "vehicle_type")
	s.UnloadWeight = field.NewFloat32(table, "unload_weight")
	s.VehicleName = field.NewString(table, "vehicle_name")
	s.DriverName = field.NewString(table, "driver_name")
	s.OwnerName = field.NewString(table, "owner_name")
	s.CarrierName = field.NewString(table, "carrier_name")

	s.fillFieldMap()

	return s
}

func (s *shipmentPrice) WithContext(ctx context.Context) *shipmentPriceDo {
	return s.shipmentPriceDo.WithContext(ctx)
}

func (s shipmentPrice) TableName() string { return s.shipmentPriceDo.TableName() }

func (s shipmentPrice) Alias() string { return s.shipmentPriceDo.Alias() }

func (s shipmentPrice) Columns(cols ...field.Expr) gen.Columns {
	return s.shipmentPriceDo.Columns(cols...)
}

func (s *shipmentPrice) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *shipmentPrice) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 22)
	s.fieldMap["id"] = s.ID
	s.fieldMap["origin_longitude"] = s.OriginLongitude
	s.fieldMap["origin_latitude"] = s.OriginLatitude
	s.fieldMap["origin_name"] = s.OriginName
	s.fieldMap["origin_province"] = s.OriginProvince
	s.fieldMap["origin_city"] = s.OriginCity
	s.fieldMap["origin_county"] = s.OriginCounty
	s.fieldMap["destination_longitude"] = s.DestinationLongitude
	s.fieldMap["destination_latitude"] = s.DestinationLatitude
	s.fieldMap["destination_province"] = s.DestinationProvince
	s.fieldMap["destination_city"] = s.DestinationCity
	s.fieldMap["destination_county"] = s.DestinationCounty
	s.fieldMap["shipment_unit_price"] = s.ShipmentUnitPrice
	s.fieldMap["shipment_distance"] = s.ShipmentDistance
	s.fieldMap["arrival_time"] = s.ArrivalTime
	s.fieldMap["product_type"] = s.ProductType
	s.fieldMap["vehicle_type"] = s.VehicleType
	s.fieldMap["unload_weight"] = s.UnloadWeight
	s.fieldMap["vehicle_name"] = s.VehicleName
	s.fieldMap["driver_name"] = s.DriverName
	s.fieldMap["owner_name"] = s.OwnerName
	s.fieldMap["carrier_name"] = s.CarrierName
}

func (s shipmentPrice) clone(db *gorm.DB) shipmentPrice {
	s.shipmentPriceDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s shipmentPrice) replaceDB(db *gorm.DB) shipmentPrice {
	s.shipmentPriceDo.ReplaceDB(db)
	return s
}

type shipmentPriceDo struct{ gen.DO }

func (s shipmentPriceDo) Debug() *shipmentPriceDo {
	return s.withDO(s.DO.Debug())
}

func (s shipmentPriceDo) WithContext(ctx context.Context) *shipmentPriceDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s shipmentPriceDo) ReadDB() *shipmentPriceDo {
	return s.Clauses(dbresolver.Read)
}

func (s shipmentPriceDo) WriteDB() *shipmentPriceDo {
	return s.Clauses(dbresolver.Write)
}

func (s shipmentPriceDo) Session(config *gorm.Session) *shipmentPriceDo {
	return s.withDO(s.DO.Session(config))
}

func (s shipmentPriceDo) Clauses(conds ...clause.Expression) *shipmentPriceDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s shipmentPriceDo) Returning(value interface{}, columns ...string) *shipmentPriceDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s shipmentPriceDo) Not(conds ...gen.Condition) *shipmentPriceDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s shipmentPriceDo) Or(conds ...gen.Condition) *shipmentPriceDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s shipmentPriceDo) Select(conds ...field.Expr) *shipmentPriceDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s shipmentPriceDo) Where(conds ...gen.Condition) *shipmentPriceDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s shipmentPriceDo) Order(conds ...field.Expr) *shipmentPriceDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s shipmentPriceDo) Distinct(cols ...field.Expr) *shipmentPriceDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s shipmentPriceDo) Omit(cols ...field.Expr) *shipmentPriceDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s shipmentPriceDo) Join(table schema.Tabler, on ...field.Expr) *shipmentPriceDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s shipmentPriceDo) LeftJoin(table schema.Tabler, on ...field.Expr) *shipmentPriceDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s shipmentPriceDo) RightJoin(table schema.Tabler, on ...field.Expr) *shipmentPriceDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s shipmentPriceDo) Group(cols ...field.Expr) *shipmentPriceDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s shipmentPriceDo) Having(conds ...gen.Condition) *shipmentPriceDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s shipmentPriceDo) Limit(limit int) *shipmentPriceDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s shipmentPriceDo) Offset(offset int) *shipmentPriceDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s shipmentPriceDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *shipmentPriceDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s shipmentPriceDo) Unscoped() *shipmentPriceDo {
	return s.withDO(s.DO.Unscoped())
}

func (s shipmentPriceDo) Create(values ...*model.ShipmentPrice) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s shipmentPriceDo) CreateInBatches(values []*model.ShipmentPrice, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s shipmentPriceDo) Save(values ...*model.ShipmentPrice) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s shipmentPriceDo) First() (*model.ShipmentPrice, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ShipmentPrice), nil
	}
}

func (s shipmentPriceDo) Take() (*model.ShipmentPrice, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ShipmentPrice), nil
	}
}

func (s shipmentPriceDo) Last() (*model.ShipmentPrice, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ShipmentPrice), nil
	}
}

func (s shipmentPriceDo) Find() ([]*model.ShipmentPrice, error) {
	result, err := s.DO.Find()
	return result.([]*model.ShipmentPrice), err
}

func (s shipmentPriceDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ShipmentPrice, err error) {
	buf := make([]*model.ShipmentPrice, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s shipmentPriceDo) FindInBatches(result *[]*model.ShipmentPrice, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s shipmentPriceDo) Attrs(attrs ...field.AssignExpr) *shipmentPriceDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s shipmentPriceDo) Assign(attrs ...field.AssignExpr) *shipmentPriceDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s shipmentPriceDo) Joins(fields ...field.RelationField) *shipmentPriceDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s shipmentPriceDo) Preload(fields ...field.RelationField) *shipmentPriceDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s shipmentPriceDo) FirstOrInit() (*model.ShipmentPrice, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ShipmentPrice), nil
	}
}

func (s shipmentPriceDo) FirstOrCreate() (*model.ShipmentPrice, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ShipmentPrice), nil
	}
}

func (s shipmentPriceDo) FindByPage(offset int, limit int) (result []*model.ShipmentPrice, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s shipmentPriceDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s shipmentPriceDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s shipmentPriceDo) Delete(models ...*model.ShipmentPrice) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *shipmentPriceDo) withDO(do gen.Dao) *shipmentPriceDo {
	s.DO = *do.(*gen.DO)
	return s
}
